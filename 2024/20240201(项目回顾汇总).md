## 项目回顾汇总

### 业务线集成平台

#### 即时通讯 IM 客服聊天

1.webSocket 技术
概念：基于 TCP 的一种应用层网络协议，提供了一个全双工的通道，允许服务器和客户端之间的实时双向通信，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。
WebSocket 数据帧结构和控制帧结构：
1.WebSocket 数据帧主要包括两个部分：帧头和有效载荷。  
 2.WebSocket 协议还包括一些控制帧，主要包括 Ping、Pong 和 Close 帧。
Ping 帧用于测试客户端和服务端之间的连接状态，客户端向服务端发送 Ping 帧，服务端收到后需要向客户端发送 Pong 帧进行响应。
Close 帧用于关闭客户端和服务端之间的连接

    为什么需要WebSocket？
        HTTP协议通信只能由客户端发起，服务器主动向客户端推送信息。一些需要实时的场景需求通过轮询的话效率低且浪费资源

    WebSocket心跳机制
        前端实现WebSocket心跳机制：1.使用setInterval定时发送心跳包 2.在前端监听到WebSocket的onclose()事件时，重新创建WebSocket连接。3.使用比如Sockjs、Stompjs这样的插件库
        （第一种方式会对服务器造成很大的压力，因为即使WebSocket连接正常，也要定时发送心跳包，从而消耗服务器资源。第二种方式虽然减轻了服务器的负担，但是在重连时可能会丢失一些数据。）

        WebSocket心跳包是WebSocket协议的保活机制，用于维持长连接。有效的心跳包可以防止长时间不通讯时，WebSocket自动断开连接。
        心跳包是指在一定时间间隔内，WebSocket发送的空数据包。常见的WebSocket心跳包机制如下：
            1.客户端定时向服务器发送心跳数据包，以保持长连接。
            2.服务器定时向客户端发送心跳数据包，以检测客户端连接是否正常。
            3.双向发送心跳数据包。

        WebSocket心跳机制原理
            1.客户端建立WebSocket连接。
            2.客户端向服务器发送心跳数据包，服务器接收并返回一个表示接收到心跳数据包的响应。
            3.当服务器没有及时接收到客户端发送的心跳数据包时，服务器会发送一个关闭连接的请求。
            4.服务器定时向客户端发送心跳数据包，客户端接收并返回一个表示接收到心跳数据包的响应。
            5.当客户端没有及时接收到服务器发送的心跳数据包时，客户端会重新连接WebSocket

2.重连退避机制
通常服务端会提供 lbs（Location Based Services，LBS）接口，来提供最优节点，我们端上要做便是缓存这些地址并设定端上的重连退避机制。按级别次数进行（重连、换连接地址重连、重新获取连接地址、上层处理）处理

3.聊天记录监控预警
监听 websocket 的 message 事件获取聊天信息，然后对应的处理聊天信息

4.消息合并和缓冲解决 UI 卡顿
因为在聊天室的场景下，每个消息的添加都会触发回流，当存在在极短时间内大量消息时，就可能会引起页面卡顿。所以需要尽量减少回流的触发，就可以考虑消息合并和缓冲。
服务端和客户端约定好解析协议，服务端将消息合并发送给客户端，客户端接收合并消息并批量展示在页面上。

5.indexDB 实现增量同步会话和历史记录
只同步自上次同步以来发生的变化，而不是同步所有数据
在用户打开聊天窗口时，若会话和历史记录一次性都由服务器返回，会增加页面等待时间以及服务器压力。所以考虑使用 IndexedDB 实现增量同步会话和历史记录。
以减少网络传输、提高响应速度。

    为什么使用indexDB?
        1.indexDB支持异步，能够很好的减少等待时间，而类似localStorage是同步的
        2.indexDB存储空间大一般250MB
        3.indexDB支持事务，在一系列操作中，只要有一步失败了，就会回滚到事务发生前的状态，不会只改写一部分数据
        4.indexDB支持存储的数据格式多，不仅可以存储字符串，也可以存储二进制数据

6.虚拟列表
使用交叉观察器实现，intersectionObserver(func,options),其中 options 的 rootMain 特别符合虚拟列表中的缓存区设计

### 在线培训平台

1.文件分片上传、秒传、断点续传（https://blog.csdn.net/CRMEB/article/details/135203003）
分片上传：使用 File Api 对大文件分割成固定大小的块，然后将每个块都上传到服务器，然后发送一个合并请求，同时根据文件内容计算生成唯一的 hash 也传递到服务器以区分文件块（使用 spark-md5 工具）
秒传：在上传前，计算文件的 hash 并将其上传到服务器来得知是否存在该文件，若存在，就直接提示上传成功
断点续传：在分片上传的时候给对应的分片加上传状态，当上传中断后重新上传，则通过每个分片的上传状态来判断是否上传

### 低代码平台物料组件

    低代码平台如何加载组件？
        通过远程异步组件的形式加载组件物料

### 自研组件库

    采用的是pnpm + monorepo的开发模式
    这样的开发模式对于组件库项目来说是一个比较好的选择。因为一个组件库可以划分为components包，theme包，docs包等，使用monorepo可以使这些包完全独立，复用更加灵活，且这些包之间产生的相互依赖也能够实时更新。

    monorepo模式是通过包管理工具的workspace功能来实现的

    为什么选择pnpm？
    主要是因为pnpm解决了npm,yarn的幽灵依赖的遗留问题。
    幽灵依赖：是指项目中存在但是未被定义在package.json中的包，即被定义的包的依赖。
    由于npm和yarn的扁平化依赖算法，所以会让这些幽灵依赖也被下载在项目中。

    幽灵依赖会产生的问题：（https://juejin.cn/post/7237352232014266429?searchId=202402012106037AF3D4E8ADF8774B5C95#heading-9）
        1.占用项目存储空间2.增加项目构建的速度3.增加潜在的安全风险，如幽灵依赖丢失(代码引用了幽灵依赖，但是幽灵依赖的引用包升级后不需要幽灵依赖了)，不兼容的幽灵依赖api等

    pnpm的解决办法，通过硬链接的方式节约磁盘空间利用率，采用虚拟存储目录（.pnpm文件） + 软连接（符号链接）解决幽灵以来
    硬链接： 电脑文件系统中的多个文件平等的共享同一个文件存储单元。
    软连接：包含一条以绝对路径或相对路径的形式指向其他文件或者目录的引用。

### 前端监控 SDK

    内部采用navigator.sendBeacon > image > xml
    发送优先级:

navigator.sendBeacon 浏览器支持 sendBeacon 且 发送数据在 60kb 以内
image 浏览器不支持 sendBeacon 且 发送数据在 2kb 以内
xml 浏览器不支持 sendBeacon 发送数据大于 2kb 或 发送数据大于 60kb

    行为：通过给document添加addEventListener全局监听点击事件，从而获取点击元素的相关信息（自定义属性），从而上报

    路由： 路由有hash\history两种模式，
        history是通过pushState()和 replaceState()来实现的，所以可以通过监听onpopstate来监听路由变化。
        hash是通过修改URL的hash值来实现的，所以可以通过监听onhashchange来监听路由变化。
        所以判断当前是history模式还是hash模式来对应使用两种方式（通过window.location.pathname来获取当前页面的路由信息，hash带#,history不带#）

    性能：使用Performance API来实现，
            1. 性能数据捕获：通过window.performance.timing对象获取页面加载过程中各个关键节点的性能数据。
            2. 各个阶段的加载时间：通过计算各个阶段（如重定向、DNS解析、TCP连接等）的耗时情况来分析优化性能瓶颈。可以记录各个阶段的耗时，并进行相应处理，如上报耗时数据到后端服务器或展示给用户。

    错误监控：     捕获前端应用程序中的JavaScript错误、网络请求错误等。
            1.JS执行错误 ：通过监听window.onerror事件，捕获页面中的JavaScript错误。
            2. Promise异常：通过监听unhandledrejection事件，捕获Promise对象的异常
            3. 资源异常：通过监听window.onload事件和error事件，捕获页面中加载的资源（如图片、CSS、JS等）加载失败或出错的情况。
            4. 接口错误：通过拦截XMLHttpRequest对象，对其进行一定程度的重写，来监听接口请求返回的状态码和异常情况。
                    比如重写onerror，ontimeout，在这些方法上通过Object.defineProperty进行劫持监听。
                    最后：
                        Object.defineProperty(window, 'XMLHttpRequest', {
                            configurable: true,
                            enumerable: true,
                            writable: true,
                            value: newXHR
                        });
