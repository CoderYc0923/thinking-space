## 项目回顾汇总

### 业务线集成平台

#### 即时通讯 IM 客服聊天

1.webSocket 技术
概念：基于 TCP 的一种应用层网络协议，提供了一个全双工的通道，允许服务器和客户端之间的实时双向通信，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。
WebSocket 数据帧结构和控制帧结构：
1.WebSocket 数据帧主要包括两个部分：帧头和有效载荷。  
 2.WebSocket 协议还包括一些控制帧，主要包括 Ping、Pong 和 Close 帧。
Ping 帧用于测试客户端和服务端之间的连接状态，客户端向服务端发送 Ping 帧，服务端收到后需要向客户端发送 Pong 帧进行响应。
Close 帧用于关闭客户端和服务端之间的连接

    为什么需要WebSocket？
        HTTP协议通信只能由客户端发起，服务器主动向客户端推送信息。一些需要实时的场景需求通过轮询的话效率低且浪费资源

    WebSocket心跳机制
        前端实现WebSocket心跳机制：1.使用setInterval定时发送心跳包 2.在前端监听到WebSocket的onclose()事件时，重新创建WebSocket连接。3.使用比如Sockjs、Stompjs这样的插件库
        （第一种方式会对服务器造成很大的压力，因为即使WebSocket连接正常，也要定时发送心跳包，从而消耗服务器资源。第二种方式虽然减轻了服务器的负担，但是在重连时可能会丢失一些数据。）

        WebSocket心跳包是WebSocket协议的保活机制，用于维持长连接。有效的心跳包可以防止长时间不通讯时，WebSocket自动断开连接。
        心跳包是指在一定时间间隔内，WebSocket发送的空数据包。常见的WebSocket心跳包机制如下：
            1.客户端定时向服务器发送心跳数据包，以保持长连接。
            2.服务器定时向客户端发送心跳数据包，以检测客户端连接是否正常。
            3.双向发送心跳数据包。

        WebSocket心跳机制原理
            1.客户端建立WebSocket连接。
            2.客户端向服务器发送心跳数据包，服务器接收并返回一个表示接收到心跳数据包的响应。
            3.当服务器没有及时接收到客户端发送的心跳数据包时，服务器会发送一个关闭连接的请求。
            4.服务器定时向客户端发送心跳数据包，客户端接收并返回一个表示接收到心跳数据包的响应。
            5.当客户端没有及时接收到服务器发送的心跳数据包时，客户端会重新连接WebSocket

2.重连退避机制
通常服务端会提供 lbs（Location Based Services，LBS）接口，来提供最优节点，我们端上要做便是缓存这些地址并设定端上的重连退避机制。按级别次数进行（重连、换连接地址重连、重新获取连接地址、上层处理）处理

3.聊天记录监控预警
监听 websocket 的 message 事件获取聊天信息，然后对应的处理聊天信息

4.消息合并和缓冲解决 UI 卡顿
因为在聊天室的场景下，每个消息的添加都会触发回流，当存在在极短时间内大量消息时，就可能会引起页面卡顿。所以需要尽量减少回流的触发，就可以考虑消息合并和缓冲。
服务端和客户端约定好解析协议，服务端将消息合并发送给客户端，客户端接收合并消息并批量展示在页面上。

5.indexDB 实现增量同步会话和历史记录
只同步自上次同步以来发生的变化，而不是同步所有数据
在用户打开聊天窗口时，若会话和历史记录一次性都由服务器返回，会增加页面等待时间以及服务器压力。所以考虑使用 IndexedDB 实现增量同步会话和历史记录。
以减少网络传输、提高响应速度。

    为什么使用indexDB?
        1.indexDB支持异步，能够很好的减少等待时间，而类似localStorage是同步的
        2.indexDB存储空间大一般250MB
        3.indexDB支持事务，在一系列操作中，只要有一步失败了，就会回滚到事务发生前的状态，不会只改写一部分数据
        4.indexDB支持存储的数据格式多，不仅可以存储字符串，也可以存储二进制数据

6.虚拟列表
使用交叉观察器实现，intersectionObserver(func,options),其中 options 的 rootMain 特别符合虚拟列表中的缓存区设计

### 在线培训平台

1.文件分片上传、秒传、断点续传（https://blog.csdn.net/CRMEB/article/details/135203003）
分片上传：使用 File Api 对大文件分割成固定大小的块，然后将每个块都上传到服务器，然后发送一个合并请求，同时根据文件内容计算生成唯一的 hash 也传递到服务器以区分文件块（使用 spark-md5 工具）
秒传：在上传前，计算文件的 hash 并将其上传到服务器来得知是否存在该文件，若存在，就直接提示上传成功
断点续传：在分片上传的时候给对应的分片加上传状态，当上传中断后重新上传，则通过每个分片的上传状态来判断是否上传

#### 2024-02-18

为什么做分片： B 端上传课件，小的几十 M，大的 1G+，不做分片的话会遇到几个问题：文件超出服务端的请求大小限制、请求时间过长超时、传输中断后只能重新上传
文件分片： 1.通过 file.slice 进行分割，每片大概 4mb 左右（分片大小根据实际情况定）
分片请求上传，用的是并发上传。（串行阻塞上传就用 async/await）: （浏览器一般允许最多同时发送多少个请求：一般是 6 个， 分浏览器，http1.1 下有些是 4，但一般是 6 个）
并发控制最大数量，其中通过 promise.race 来等待并发池中最快任务的完成，然后补上新的请求，直到全部任务结束返回一个 promise。（并发上传如何控制分片顺序？每个分片请求都会在参数中标明当前属于哪一块）
断点续传怎么做：断点续传可分为手动中断、网络异常停止、手动刷新页面等：
所以根据整个文件的内容做一个 hash，并在每一片上传的时候，把文件的 hash 传过去。后面客户端每次上传时，先把文件 hash 拿到后端去匹配，若之前上传过，就返回当前文件上传的分片 index。根据返回的 Index 来分辨是传完了还是续传，续传就从 index 下一个开始传
tip: 优化：当文件超级大时，做文件的 hash 可能会需要很长时间，可以通过 webworker 开启一个线程来单独处理文件的 hash。（https://blog.csdn.net/weixin_46603441/article/details/131888778）
具体：通过 SparkMD5 来根据文件的二进制内容计算文件的 hash。传入切片后的 chunkList，利用 fileReader 读取每个切片的 arraybuffer 并不断传入 sarkmd5 中，每计算完一个切片通过 postmessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程

#### 前端项目打包体积过大如何优化：

1.按需加载，通过路由懒加载,以及若用到组件库可以按需导入组件库而不是全部导入 2.优化图像和多媒体资源，比如适当的压缩图片的体积、使用 webp 格式图像等 3.使用 gzip 代码压缩（compression-webpack-plugin） 5.使用 tree-sharking 去除无用代码（webpack 开启 mode: 'production'） 6.提取公共代码，代码分割（webpack 中在 optimization 中配置） 7.通过 cdn 引入公共依赖（比如 vue、echarts 等），并在 webpack 中通过 externals 排除该依赖 8.减小三方依赖的体积（使用 moment-locales-webpack-plugin）
9.DLLPlugin 动态链接库，将依赖单独打包，这样后面每次只构建业务代码。并使用 DLLReferencePlugin 将打包生成的 dll 文件引用到需要的预编译的依赖上，并通过 html-webpack-tags-plugin 在打包时自动插入 dll 文件

### 低代码平台物料组件

    低代码平台如何加载组件？
        通过远程异步组件的形式加载组件物料

### 自研组件库

    采用的是pnpm + monorepo的开发模式
    这样的开发模式对于组件库项目来说是一个比较好的选择。因为一个组件库可以划分为components包，theme包，docs包等，使用monorepo可以使这些包完全独立，复用更加灵活，且这些包之间产生的相互依赖也能够实时更新。

    monorepo模式是通过包管理工具的workspace功能来实现的

    为什么选择pnpm？
    主要是因为pnpm解决了npm,yarn的幽灵依赖的遗留问题。
    幽灵依赖：是指项目中存在但是未被定义在package.json中的包，即被定义的包的依赖。
    由于npm和yarn的扁平化依赖算法，所以会让这些幽灵依赖也被下载在项目中。

    幽灵依赖会产生的问题：（https://juejin.cn/post/7237352232014266429?searchId=202402012106037AF3D4E8ADF8774B5C95#heading-9）
        1.占用项目存储空间2.增加项目构建的速度3.增加潜在的安全风险，如幽灵依赖丢失(代码引用了幽灵依赖，但是幽灵依赖的引用包升级后不需要幽灵依赖了)，不兼容的幽灵依赖api等

    pnpm的解决办法，通过硬链接的方式节约磁盘空间利用率，采用虚拟存储目录（.pnpm文件） + 软连接（符号链接）解决幽灵以来
    硬链接： 电脑文件系统中的多个文件平等的共享同一个文件存储单元。
    软连接：包含一条以绝对路径或相对路径的形式指向其他文件或者目录的引用。

### 前端监控 SDK

    内部采用navigator.sendBeacon > image > xml
    发送优先级:

navigator.sendBeacon 浏览器支持 sendBeacon 且 发送数据在 60kb 以内
image 浏览器不支持 sendBeacon 且 发送数据在 2kb 以内
xml 浏览器不支持 sendBeacon 发送数据大于 2kb 或 发送数据大于 60kb

    行为：通过给document添加addEventListener全局监听点击事件，从而获取点击元素的相关信息（自定义属性），从而上报

    路由： 路由有hash\history两种模式，
        history是通过pushState()和 replaceState()来实现的，所以可以通过监听onpopstate来监听路由变化。
        hash是通过修改URL的hash值来实现的，所以可以通过监听onhashchange来监听路由变化。
        所以判断当前是history模式还是hash模式来对应使用两种方式（通过window.location.pathname来获取当前页面的路由信息，hash带#,history不带#）

    性能：使用Performance API来实现，
            1. 性能数据捕获：通过window.performance.timing对象获取页面加载过程中各个关键节点的性能数据。
            2. 各个阶段的加载时间：通过计算各个阶段（如重定向、DNS解析、TCP连接等）的耗时情况来分析优化性能瓶颈。可以记录各个阶段的耗时，并进行相应处理，如上报耗时数据到后端服务器或展示给用户。

    错误监控：     捕获前端应用程序中的JavaScript错误、网络请求错误等。
            1.JS执行错误、资源异常 ：通过监听window.addEventListen('error', true)事件，捕获。
            2. Promise异常(接口)：通过监听unhandledrejection事件，捕获Promise对象的异常
