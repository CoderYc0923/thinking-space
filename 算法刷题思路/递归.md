# 定义： 递归是调用自身，且将一个大问题分解成若干个相同或相似的子问题

# 条件：1.递归条件 2.递归公式

# 递归是一种应用广泛的编程技巧，如果要使用递归，需要满足三个条件。

## （1）一个问题的解可以分解为几个子问题的解。

## （2）这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。

## （3）存在递归终止条件，即基线条件（Base Case）。

### 注意，递归的关键就是找到将大问题分解为小问题的规律（推荐画出递归树），基于此写出递推公式，然后再推敲终止条件，并且需要警惕重复计算。下面是一个递归的大致模板。

```
function recursion(level, param1, param2, ...) {
  //递归的终止条件
  if(level > MAX_LEVEL) {
    console.log("result");
    return;
  }
  //数据处理
  processData(level, data1,...);
  //继续递归
  recursion(level + 1, p1, ...);
  //收尾工作
  reverseState(level);
}
```

### 递归的数学模型就是归纳法，其过程如下。

（1）基础情况：证明 P(b)语句成立，该步骤只需带入数字即可。
（2）声明假设：假设 P(n)语句成立。
（3）归纳步骤：证明如果 P(n)语句成立，那么 P(n+1) 语句也一定成立。

```
例如设计一程序，求自然数 N 的阶乘 N!。
（1）当 N=1 时，N!=1。
（2）假设 P(N)=N!，P(N+1)=(N+1)!。
（3）证明 P(N) 和 P(N+1) 的关系：P(N+1) = (N+1)! = (N+1)×(N)×…×2×1 = (N+1)×N! = (N+1)×P(N)
根据这个公式可构造一个递归函数：
function factorial(N) {
  return N * factorial(N - 1);   //递归部分
}

//在采用数学归纳法设计递归程序后，就能摆脱每一步的递推，直接根据分析就能转化为代码。
 //试图想清楚整个递和归过程的做法，实际上是一种思维误区，不符合人脑平铺直叙的思维方式。
```
